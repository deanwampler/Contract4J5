<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Contract4J</title>
	<meta name="generator" content="TextMate http://macromates.com/">
	<meta name="author" content="Dean Wampler">
	<meta name="keywords"
	  content="aspect-oriented programming, aspect-oriented software development, object-oriented programming, ruby, ruby on rails, aspectj, aop, aosd, software">
	<meta name="copyright" content="Copyright 2003-2006 Aspect Research Associates, All Rights Reserved">
  <link href="/stylesheets/styles.css?" media="all" rel="Stylesheet" type="text/css" />
  <script src="/javascripts/prototype.js?1145459934" type="text/javascript"></script>
<script src="/javascripts/effects.js?1145459934" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1145459934" type="text/javascript"></script>
<script src="/javascripts/controls.js?1145459934" type="text/javascript"></script>
<script src="/javascripts/application.js?1145459934" type="text/javascript"></script>
  <script type="text/javascript">
		window.onload = function() {
		  $('search-text').value = '';
		  $('search').onsubmit = function() {
		    $('search-text').value = "site:www.contract4j.org " + $F('search-text');
		  }
			select_first_form_field_if_any()
		}
  </script>
</head>

<body class="Contract4J"> <!-- onload="select_first_form_field_if_any();"-->
  <div id="page">
    <div id="content">
			<div id="logo-Contract4J">
			</div>
      <div id="header">
        <h1>README for Contract4J5:<br/>Contracts Using Java 5 Annotations</h1>
      </div>
      <div id="main">

          <h3>History</h3>
<table>
	<tr><th colspan='2' align="left">Contract4J5 (Annotation Form)</th></tr>
	<tr><td>v0.7.0.0</td><td>December 31, 2006</td></tr>
	<tr><td>v0.6.0.0</td><td>September 21, 2006</td></tr>
	<tr><td>v0.5.0.0</td><td>February 7, 2006</td></tr>
	<tr><td>v0.1.1.0</td><td>October 4, 2005</td></tr>
	<tr><td>v0.1.0.2</td><td>April 24, 2005</td></tr>
	<tr><td>v0.1.0.1</td><td>February 6, 2005</td></tr>
	<tr><td>v0.1.0.0</td><td>January 31, 2005</td></tr>
	<tr><td colspan='2'/></tr>
	<tr><th colspan='2' align="left">Contract4JBeans (Experimental)</th></tr>
	<tr><td>v0.3.0.0</td><td>February 20, 2006</td></tr>
	<tr><td>v0.2.0.0</td><td>October 5, 2005</td></tr>
	<tr><td>v0.2.0.0M1</td><td>August 15, 2005</td></tr>
</table>
<p>
Dean Wampler<br/> 
<a href="http://www.contract4j.org">Contract4J5.org</a><br/>
<a href="http://www.aspectprogramming.com">aspectprogramming.com</a><br/>
A project of <a href="http://www.aspectresearchassociates.com/">Aspect Research Associates</a>
</p>

<h3>Contents</h3>
<ul>
	<li><a href='#copyright'>Copyright</a></li>
	<li><a href='#wheretogetc4j'>Where to Get Contract4J5</a></li>
	<li><a href='#versioning'>Naming and Versioning</a></li>
	<li><a href='#manifest'>Distribution Manifest</a></li>
	<li><a href='#whatisc4j'>What Is "Contract4J5"?</a></li>
	<li><ul>
		<li><a href='#whatisdbc'>What is Design by Contract?</a></li>
  	<li><a href='#dbcandaop'>Design by Contract and Aspect-Oriented Programming</a></li>
  	<li><a href='#how'>How Does Contract4J5 Support Design by Contract?</a>
			<ul>
  			<li><a href='#inherit'>Inheritance Behavior of Contracts</a></li>
			</ul></li>
  	<li><a href='#usage'>How Do I Use Contract4J5?</a></li>
  	<li><a href='#showme'>Show Me the Code!</a></li>
  	<li><a href='#details'>Details of Contract Specifications</a></li>
  	<li><a href='#tips'>Miscellaneous Notes and Debugging Tips</a></li>
  	<li><a href='#config'>Configuration of Contract4J5</a></li>
	</ul></li>
	<li><a href='#todo'>TODO Items</a></li>
	<li><a href='#notes'>Notes for Each Release</a></li>
	<li><a href='#furtherinfo'>For Further Information...</a></li>
</ul>

<b>Impatient?</b> If you want to get started quickly, see the <a href="http://www.contract4j.org/contract4j/example">Quick Example</a>. To see what Java code looks like with <span class="keyword">Contract4J5</span> in 
action, go to <a href='#showme'>Show Me the Code!</a>.


<a name="copyright"></a>
<h3>Copyright</h3>
<p>
<span class="keyword">Contract4J</span> is open source software covered by
the Eclipse Public License - v 1.0. A complete copy of the license is shown
below and it can be found in the <code>LICENSE-ECLIPSE.txt</code> file in
the top-level directory of the distribution.
</p>
<pre>
===========================================================
Copyright 2005,2006 Dean Wampler

   Licensed under the Eclipse Public License - v 1.0; you
   may not use this software except in compliance with the 
   License. You may obtain a copy of the License at

       http://www.eclipse.org/legal/epl-v10.html

   A copy is also included with this distribution. See the
   "LICENSE" file. Unless required by applicable law or 
   agreed to in writing, software distributed under the 
   License is distributed on an "AS IS" BASIS, WITHOUT 
   WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied. See the License for the specific language 
   governing permissions and limitations under the License.
==========================================================
</pre>
<p>In addition, several third-party components are used by Contract4J5. Their
licenses are described by the <code>LICENSE.txt</code> file.</p>

<a name='wheretogetc4j'></a>
<h3>Where to Get Contract4J5</h3>
<p>
<i>Contract4J5</i> is available from the 
<a href="http://www.contract4j.org">contract4j.org</a> web site. The 
distributions are actually hosted on
<a href="https://sourceforge.net/project/showfiles.php?group_id=130191">sourceforge.net</a>. 
Anonymous Subversion access is also available at this path:
<code>https://contract4j.svn.sourceforge.net/svnroot/contract4j</code>.</p>

<a name="versioning"></a>
<h3>Naming and Versioning</h3>
<p>
The active development project is <i>Contract4J5</i>, which uses Java 5
annotations to define the contracts. There is a separate, dormant project
called <i>Contract4JBeans</i>, which was an interesting but not very successful
experiment that required no Java 5 annotations, but relied on
method naming conventions to define contracts for target methods and classes.
The JavaBeans-like naming conventions were the origin of the
<i>Contract4JBeans</i> name. Both versions are available at <a 
href="http://www.contract4j.org">contract4j.org</a> (only <i>Contract4J5</i> is
available through subversion).</p>

<p>The newest release of <i>Contract4J5</i> described in these notes is
version 0.7.0.
It is "pre-1.0" while planned features are implemented, which may force 
API changes that break backwards-compatibility. A stable "1.0" release will
probably happen in early 2007.</p>

<a name="manifest"></a>
<h3>Distribution Manifest</h3>
<p>
Contract4J5 comes in <code>*.zip</code> and <code>*.tar.gz</code> formats.
For convience, each archive includes the required Jexl, Groovy, JRuby and
dependent libraries. If you are using only one of the languages, a table below
lists which of the jars is required for each language choice. (The Spring
framework is not included.)</p>
<p>
After expanding the archive you will have the following directory structure:</p>
<table border='1'>
  <tr><th>File or Directory</th><th>Description</th></tr>
  <tr><td><code>contract4j5_XYZ.jar</code></td><td>Pre-built Contract4J5 jar.</td></tr>
  <tr><td><code>lib</code></td><td>Location of Jexl, Groovy, JRuby and dependent libraries.</td></tr>
	<tr><td><code>contract4j5</code></td><td>Directory with the main distribution files</td></tr>
	<tr><td valign="top"><code>contract4j5WithSpring</code></td><td>Directory with an example of configuring Contract4J5 using Spring 1.2.X or Spring 2.0. The example works with either release (it uses the 1.2.X API, which is supported by 2.0). We recommend using Spring for customizations. However, without any configuration, Contract4J5 works with suitable defaults. There is also a property configuration option, demonstrated in the JUnit tests and discussed in more detail below.</td></tr>
</table>

<p>Inside the <code>contract4j5</code> directory, you will find:</p>
<table border='1'>
	<tr><td><code>ant</code></td><td>Directory of ant support files.</td></tr>
  <tr><td><code>build.bat</code></td><td>Window's build driver script.</td></tr>
  <tr><td><code>build.sh</code></td><td>Linux/MacOSX/Cygwin build driver script.</td></tr>
  <tr><td><code>build.xml</code></td><td>Ant build script.</td></tr>
  <tr><td><code>Contract4J.properties.example</code></td><td>Example properties file for configuring Contract4J5 using properties. Note that we recommend using Spring for this purpose.</td></tr>
  <tr><td><code>doc</code></td><td>Created during a full build; where Javadocs go. </td></tr>
  <tr><td><code>env.bat</code></td><td>Windows environment variable setup for running the build. Invoked by <code>build.bat</code>. Edit this file for your environment.</td></tr>
  <tr><td><code>env.sh</code></td><td>Linux, MacOSX, Cygwin environment variable setup for running the build. Invoked by <code>build.sh</code>. Edit this file for your environment.</td></tr>
  <tr><td><code>jdepend.sh</code></td><td>*nix driver script for <a href="http://clarkware.com/software/JDepend.html">jdepend</a>. Uses XSLT and Graphviz to generate a PNG file with the results. See the script for more information.</td></tr>
  <tr><td><code>jdepend.bak</code></td><td>Created when you run the <i>jdepend.sh</i> script; results from previous runs are stored here. </td></tr>
  <tr><td><code>jdepend.properties</code></td><td>Configure <i>jdepend</i>.</td></tr>
  <tr><td><code>jdepend_report.png</code></td><td>Example output generated by <i>jdepend.sh</i>.</td></tr>
  <tr><td><code>LICENSE.txt</code></td><td>Contract4J license file (Eclipse Public License 1.0). Other license files for included components may also appear in this directory.</tr>
  <tr><td><code>README.html</code></td><td>This README.</td></tr>
  <tr><td><code>src</code></td><td>Directory with all the non-test source files</td></tr>
  <tr><td><code>src-classes</code></td><td>Created during a build; where the <code>src</code> classes go.</td></tr>
  <tr><td><code>test</code></td><td>Directory with all of Contract4J5's JUnit test sources.</td></tr>
  <tr><td><code>test-classes</code></td><td>Created during a build; where the <code>test</code> classes go.</td></tr>
</table>


<a name="whatisc4j"></a>
<h3>What Is "Contract4J5"?</h3>
<p>
<b>Contract4J5</b> supports "Design by Contract"(TM) programming in Java. a programming
practice introduced by Bertrand Meyer and incorporated in the Eiffel 
programming language in the 1980's. </p>
<p>
The Contract4J5 project is sponsored by <a href="http://www.aspectresearchassociates.com">Aspect Research Associates</a>, a consulting firm specializing in
Aspect-Oriented Programming, Enterprise Java, and Ruby on Rails.</p>

<a name='whatisdbc'></a>
<h4>What is Design by Contract?</h4>
<p>
<i>Design by Contract</i> (DbC) starts with the observation that, implicitly or 
explicitly, a component defines a "contract" with its clients. When a client
invokes an operation on the component, it must agree to provide the component 
with appropriate inputs and context. Otherwise, the component can't perform its 
services. In return, if the input constraints are satisfied the component
guarantees delivery of prescribed results.</p>
<p>
DbC encourages the component developer to state the contract explicitly, by 
specifying the input constraints, known as "preconditions", and guaranteed
results, known as "postconditions", in a programmatic form that can be tested
at runtime. In addition, state "invariants" may be defined. </p>
<p>
DbC is a powerful and underused tool for detecting bugs during development and
testing. A key principle is that if a test fails during execution, the program
terminates abruptly. While this may seem draconian, it forces the developer to
solve the problem immediately, rather than allow problems to "slide", multiple, and thereby undermine the quality of the software. </p>
<p>
Hence, during development, all tests are enabled and the code is thoroughly 
tested. During deployment, the tests are often disabled, both to prevent sudden
shutdown and and to allow possible recovery should a contract-violating
condition arise that was never detected during development. Turning off the 
tests also removes their overhead.</p>
<p>
As such, DbC is a wonderful complement to <a href="http://www.junit.org/news/article/test_first/index.htm">Test-Driven Development</a>, which exercises the  
code and hence the contract tests, thereby increasing the probability they will
detect bugs. DbC tends to emphasize the fine-grained design a little more than
test-driven development by itself. Designing the unit tests and specifying the
contracts also force the developer to think through the details of the design 
before writing the code. A third technique that supports thinking through the
design is to write the comment blocks for classes and methods before 
implementing them.</p>
<p>
For more on Design by Contract, see <a href="http://archive.eiffel.com/doc/manuals/technology/contract/page.html">Building bug-free O-O software: An 
introduction to Design by Contract(TM)"</a>
and the
discussion of DbC in the larger context of Agile Methods in Martin, <i>et al.</i>, 
"Agile Software Development: Principles, Patterns, and Practices", Prentice 
Hall, 2003 (ISBN 0-13-597444-5).

<a name="dbcandaop"></a>
<h4>Design by Contract and Aspect-Oriented Programming</h4>
<p>
So what does DbC have to do with <a href="http://www.aspectprogramming.com">Aspect-Oriented Programming</a> (AOP)? On the 
one hand, the component's contract is an essential part of the complete, logical
component specification that clients must support. For example, an interface for
a bank account may have a contract requirement that all methods that return a 
balance must always return a non-negative number (ignoring overdraft features).
However, in practical terms, contracts often include implementation concerns
that may have little relationship to the domain logic of the application. 
For example, the code implementing the bank account may prohibit passing null 
values as method parameters.</p>
<p>
For both types of contract details, AOP allows us to specify the details with
sufficient "proximity" to the interface so that clients can see the constraints 
and AOP gives us an elegant way of testing the constraints at runtime without
cluttering the code with logic to run the tests and handle failures.</p>
<p>
More generally, AOP is a new approach to modularizing "concerns" that need to be
handled by a component, but which tend to obscure the main logic of the 
component, often compromising clarity, maintainability, reusability, etc. For 
example, modern web and enterprise applications typically must support secure 
access, transactional behavior, persistence of data, and mundane support issues
like logging. Without AOP, the code for these "concerns" gets mixed in with the
domain logic, thereby cluttering the code and diminishing the "ilities" we all 
strive for. AOP keeps these concerns in separate modules and provides powerful
facilities for "injecting" the concern behavior in the specific execution
points where needed. Contract4J5 uses AOP techniques to find the contract
specifications and test them at runtime at the appropriate execution points.</p>
<p>
AOP is a good approach to supporting DbC because it permits DbC concerns to
be managed in a modular and minimally-intrusive way, without cluttering  
application logic, while still allowing the contracts to be integrated into the
runtime environment for development and testing. Contract4J5 uses the best-known
AOP language, AspectJ, to support DbC for Java.</p>
<p>
For more information on AOP, see the references below.</p>

<a name="how"></a>
<h4>How Does Contract4J5 Support Design by Contract?</h4>
<p>
I'm a long-time believer in DbC and wanted to use it in Java. A few years
ago, I discovered the clever <a href="http://barter.sourceforge.net/">Barter</a> project, which supports DbC in Java
using XDoclet tags and AspectJ code generation to perform the tests as "advice".</p>
<p>
Two problems with doclet-based approaches are that they are buried in the comments, which means they are decoupled from the runtime environment, and a 
preprocessor step is required. Java 5 introduced annotations, 
which are like "javadoc tags for code". In particular, annotations are used to
ascribe meta-information to the code and to make that information available to
the runtime environment, when desired. Annotations are a logical tool for 
associating contract tests with code and Contract4J5 uses them for this purpose.</p>
<p>
The specifications are written as executable Java expressions, enclosed in the
String "value()" attribute of the annotation. The details are discussed below.
A contrived example suffices for now:
<pre>
<b>@Contract</b>
public class MyClass {
  <b>@Invar ("name != null")</b>
  private String name;

  <b>@Pre ("n != null")</b>
  public void setName (String n) { name = n; }
  <b>@Post ("$return != null")</b>
  public String getName () { return name; }

  <b>@Pre ("n > 10 && s != null")</b>
  <b>@Post ("$return != null")</b>
  public String  doIt (int n, String s) {...}
  ...
}
</pre>
<p>
The <code><b>@Contract</b></code> annotation tells Contract4J5 that "MyClass" defines tests. The
tests are defined using <code><b>@Pre</b></code>, <code><b>@Post</b></code>, and <code><b>@Invar</b></code> annotations, for 
precondition, postcondition, and invariant tests respectively. In this example,
the tests are:</p>
<ol>
	<li>The field "name" has an invariant test that it can never be null (after
the object has been constructed...).</li>
	<li>The "setName" method has a precondition that the value of the parameter
cannot be null.</li>
	<li>The "getName" method has a postcondition that it can never return null.</li>
	<li>The "doIt" method has both a pre- and a postcondition test.</li>
</ol>
<p>
If a test fails, Contract4J5 throws an unchecked exception, <code><b>ContractError</b></code>, 
after printing some diagnostic information (see the unit tests for examples). 
A special subclass of ContractError is thrown if the test itself can't be 
evaluated for some reason (discussed in more detail below). That error is 
<code><b>TestSpecificationError</b></code>. So, clients who want to catch 
contract errors and also
distinguish between these two types of failures should follow this idiom:</p>
<pre>
  try {
    ...
  } catch (TestSpecificationError tse) {
    ...
  } catch (ContractError ce) {
    ...
  }
</pre>
<p>
Previous versions of Contract4J5 embedded the Jakarta
<a href="http://jakarta.apache.org/commons/jexl/">Jexl</a>
interpreter, an expression evaluator, to evaluate the test expressions in the
annotations. However, there are quirks and limitations of Jexl (discussed
throughout this README; search for "Jexl"...). Hence, starting with V0.7, 
Contract4J5 now supports Jexl, Groovy, and JRuby as scripting engine 
alternatives. The tests exercise all three options. We recommend either Groovy
or JRuby, depending on which one best suits your needs. By default, Groovy is
used.
</p>
<p>
V0.1 of Contract4J5 used a preprocessing approach. Using a plugin
for Sun's Annotation Processor Tool (APT), it generated AspectJ code that
hard-coded the test expressions. The generated code and the original code were
then compiled. </p>
<p>
V0.5 eliminated this preprocessor step, thereby simplifying adoption. All you
have to do is add a final AspectJ weaving step to your build, write your tests
in familiar annotations, and you are done. No custom AspectJ code is required.</p>
<p>
V0.6 refined the internal structure of Contract4J5 to provide better 
configuration options and to support binary weaving and load-time weaving (LTW)
as build/deployment options. (There are build targets that exercise these options.)</p>

<a name="inherit"></a>
<h5>Inheritance Behavior of Contracts</h5>
<p>
In DbC, there are rules for proper behavior of inherited contracts, based on the
Lyskov Substitution principle (LSP), which is a minimal definition of 
inheritance. Class B is considered a child class of class A, if objects of type
B can be substituted for objects of type A without breaking the program. In DbC
terms, this means that class B must obey A's contract, including all the class, 
method, and field tests.</p>
<p>
However, there is one nuance affecting derived preconditions and postconditions.
A derived (overriding) precondition test can actually satisfy a "looser"
restriction than the overridden test. Put another way, the set of valid inputs
can be larger than the set for the parent (overridden) test. This is because 
precondition tests are tests the client must meet, so if a client already meets
a strict test defined by the overridden test, then it will also satisfy a 
looser derived test transparently. This is "contravariant" behavior because
even though subclassing is a form of increasing specialization and restriction,
the restrictions imposed by the precondition test can actually grow looser.</p>
<p>
In contrast, postcondition tests are "covariant", meaning they must be as
narrow or narrower than the tests they override. This is true because
postcondition tests are tests on the results the component promises to deliver,
as opposed to tests on clients. So, if the client is expecting a result in a set
of possible results and a derived test narrows the set further, then the result
will still satisfy the client's expectations.</p>
<p>
Contract4J5 provides only minimal support for contravariant precondition tests 
and covariant postcondition tests. First, because Java 5 annotations on methods 
are NOT inherited, it is a requirement for writers of subclass method overrides 
to also include the annotations on the parent method. However, the annotations 
do not have to reproduce the test expressions. C4J5 will locate the 
corresponding parent class test expressions automatically. In contrast, 
class-level invariants are inherited, since class annotations can be inherited.
(However, it is harmless to repeat those in subclasses, too.)</p>
<p>
C4J5 attempts to enforce the rule that invariant tests can't change. However,
it uses a simple string comparison, ignoring whitespace, so some logically
equivalent expressions may get flagged incorrectly as different. For example:
<pre>
	a == b   vs.   b == a
</pre>
will appear to be different, when they are logically equivalent.</p>
<p>
To properly write contravariant precondition tests and covariant postcondition
tests, you will have to repeat the "inherited" test expression and "append"
the appropriate refinements, e.g.,
<pre>
	@Pre("new_test || parent_test")
	@Post("new_test && parent_test")
</pre>
However, since the parent test is always valid for the derived method override,
if you don't need to modify the test, then you can simply use the @Pre or @Post
annotation without a test expression and C4J5 will find the parent expression.</p>

<a name="usage"/></a>
<h4>How Do I Use Contract4J5?</h4>
<p>
The distribution contains ant files and examples of how to use Contract4J5. 
The examples are actually part of the unit/acceptance test suite. If your are 
using Eclipse, the project configuration files are also in the source 
distribution. You may or may not want to remove them.</p>
<p>
<b>NOTE:</b>  The tests/examples are the best way to see how to write test expressions correctly!</p>

<h5>Installation and Configuration:</h5>
<p>
For Linux/Unix systems, sue these commands: 
<pre>
	1) cd ~/work		# or wherever...
	3) cp .../contract4j5_060.tar.gz .
	4) tar xvzf contract4j5_060.tar.gz 
</pre>
On Windows systems, Unzip the zip file to an appropriate location.</p>
<p>
You will need to have Java 5 and AspectJ 5 installed to use Contract4J5. You
will need to select which scripting language you prefer for the annotation
scripts used to define contracts. The distribution includes all the
currently-supported options; Jakarta Commons Jexl
1.0, Groovy 1.0 RC1 (or later), and JRuby 0.9 (or later). (Commons Logging
is also included; it is required by Jexl).</p>
<p>If you build Contract4J5 yourself, you will also need JUnit 3.8.1.</p>
<p>
<b>Note:</b> You must use AspectJ v1.5.3 or later if you want to use load-time weaving
(LTW) with Contract4J5.</p>
<p>
Once you have started adding contract tests to your code, there are three ways 
to enable Contract4J5's contract enforcement:</p>
<ol>
	<li>Compile our code with <a href="http://www.aspectj.org">AspectJ's</a> <b>ajc</b> compiler instead of <b>javac</b>. You will need to add the <code>contract4j5.jar</code> to your <code>CLASSPATH</code>.</li>
	<li>Use a binary weaving step. After you compile your code with <code>javac</code>, use <code>ajc</code> to weave in the <span class="keyword">Contract4J5</span> aspects.</li>
	<li>Use load-time weaving (LTW) to apply the <span class="keyword">Contract4J5</span> aspects at runtime.</li>
</ol>
<p>
All three approaches are demonstrated by Contract4J5's <b>ant</b> build 
process, as described below. However, because load-time weaving (LTW) is the easiest 
and the least intrusive approach, we recommend it and describe it here. Follow these steps.</p>
<ol>
	<li>Install <a href="http://www.aspectj.org">AspectJ</a> v1.5.2a or later (the "a" release is required!).</li>
	<li>Make sure the <code>ASPECTJ_HOME</code> environment variable is defined.</li>
	<li>Add the <code>contract4j5.jar</code> to your <code>CLASSPATH</code> <i>and</i> your <code>ASPECTPATH</code>, if using Eclipse or ajc (<i>i.e.,</i> 
<code>-aspectpath ...</code>).
  <li>Copy and adapt the <code>test/META-INF/aop.xml</code> file to your project.</li>
	<li>Invoke your application (<i>e.g.,</i> JUnit tests) using the <code>ASPECTJ_HOME/bin/aj5</code> (*nix) or <code>%ASPECTJ_HOME%\bin\aj5.bat</code> (Windows) script, instead of <code>java</code>.</li>
</ol>
<p>
Now the Contract4J5 aspects will be applied as your application's classes as they are loaded. For production deployments, simply use <code>java</code> to invoke your application, as before. </p>
<p>
<b>Note:</b> To see how to invoke JUnit tests from ant with load-time weaving (LTW), see the "_junitTemplate.loadtime.weaving" build target in <code>ant/targets.xml</code>. This example also provides more details on how to use LTW with Contract4J5.</p>

<p>
If you are already using the AspectJ <b>ajc</b> compiler to compile your 
Java and AspectJ sources, then simply include <code>contract4j5.jar</code> in the <code>-aspectpath</code> argument to <b>ajc</b>.</p>
<p>
Another alternative, whether you use <b>ajc</b> or <b>javac</b> to build your
code, is to add a final binary weaving step to your build.</p>
<p>
To see how to do a binary weaving step, consult the Ant build files in the
distribution, in particular, the "test" target and dependencies. The 
"compile.test" target uses <b>javac</b> to compile the JUnit test code. The 
"project-test.jar" target uses <b>ajc</b> to do binary weaving, where the compiled 
class files are read by <b>ajc</b>, aspects are woven into them (note the
<code>-aspectpath</code> option to <b>ajc</b>) and the <code>contract4j5-test.jar</code> file is output. 
The <b>ant/targets.xml</b> defines the "binaryWeaveTemplate" target used for
this process.</p>
<p>
<b>Note:</b> To see what the ajc command does, invoke ant with the option 
	  <code>-Dbuild.compiler.verbose=true</code>
which will cause ajc to print the command-line options used. Look for the 
output that is part of the "compile.test" target. This output may be easier to 
understand than trying to understand the ant files!
</p>
<p>
You can use the installed <code>contract4j5.jar</code> file as is. If you want to rebuild
Contract4J5, use the ant driver script "build.sh" or "build.bat", edit the corresponding "env.sh" or "env.bat" file and change the environment variable
definitions as appropriate for your environment. Or, you can define the
appropriate environment variables in your environment and use the build.xml 
ant script directly.</p>

<p>
The distribution has the following structure:
<table>
	<tr><th width="20%" align="left">File/Directory</th><th align="left">Description</th></tr>
	<tr><td>README.txt</td><td>This file</td></tr>
	<tr><td>LICENSE.txt</td><td>The Apache 2 license file for Contract4J5</th></tr>
	<tr><td>build.sh</td><td>Unix/Linux build driver script. Sets "home" variables where the tools are found. Edit to taste.</th></tr>
	<tr><td>build.bat</td><td>Windows build driver script. Also sets "home" variables...</th></tr>
	<tr><td>build.xml</td><td>Ant build script</th></tr>
	<tr><td>src</td><td>The source code tree.</th></tr>
	<tr><td valign="top">test</td><td>The JUnit unit/acceptance tests, which also function as usage examples. The files ending with "*Test.java" are JUnit tests. The other classes under "test" are example classes used by the tests, which also provide C4J5 usage examples. The JUnit test files often contain additional example classes that demonstrate usage and they contain comments about tests the demonstrate known idiosyncrasies or limitations of C4J5 and script evaluation using Jexl, Groovy, and JRuby.</th></tr>
	<tr><td>classes</td><td>where build artifacts (except the jars) are stored.</th></tr>
	<tr><td>doc</td><td>Where Javadocs are written.</th></tr>
	<tr><td>contract4j5.jar</td><td>The runtime deployment jar. It contains the build products from "src".</th></tr>
	<tr><td>contract4j5-test.jar</td><td>The jar containing the build products from "test". Not part of the normal runtime deployment.</th></tr>
</table>
<br/>
If you want to build Contract4J5:
<pre>
	1a) ./build.sh all    (*nix)
	1b) build.bat all     (windows)
</pre>
or
<pre>
	1c) ant all
</pre>
<p>
The jar files "contract4j5.jar" and "contract4j5-test.jar" in the current
directory will be built and the unit/acceptance tests will be executed. The
tests generate a LOT of output, but they should all pass. Also, there will 
some warnings which fall into several categories:
<ol>
	<li>Warnings in some unit tests when test annotations are used without the
required @Contract annotation. This is deliberate for those tests.</li>
	<li>Unavoidable unchecked casts involving generics.</li>
	<li>The javadocs target also results in many warnings for references to aspects from Java files, which javadoc doesn't know how to resolve. To be clear, the following missing "classes" are actually aspects:
		<ul>
  		<li>AbstractConditions</li>
  		<li>ConstructorBoundaryConditions</li>
  		<li>Invariant*Conditions (several)</li>
  		<li>MethodBoundaryConditions</li>
		</ul></li>
	</li>
</ol>
For example, you'll see lots of warnings about not being able to find
members of these aspects.</p>
<p>
If the unit tests fail, look for output in <code>contract4j5/TEST-*.txt</code> files.
Usually, the problem will be a classpath issue.</p>
<p>
To build the example of wiring the components and properties of Contract4J5 
using Spring's Dependency Injection run any of the following commands after
building "all" as before:
<pre>
	2a) ./build.sh all.spring (*nix)
	2b) build.bat all.spring  (windows)
</pre>
or
<pre>
	2c) ant all.spring
</pre>
<p>
This will run a test target that confirms that Spring can "wire" Contract4J
correctly. See the following files for more details:</p>
<p>
This build target builds the example in the "sister" directory 
<code>../Contract4J5WithSpring</code>. It contains a separate example 
demonstrating how to use the Spring Framework's Dependency Injection (DI) to 
configure the properties of Contract4J. This is done separately from the main 
build so that Spring is not required for those people not using it.</p>
<p>The key files in this directory tree are the following:</p>
<ul>
	<li><code>test/org/contract4j5/configurator/spring/test/ConstructWithSpringTest.java</code>: Uses Spring's "ApplicationContext" to construct C4J, then tests that the components and properties are wired as expected.</li>
	<li><code>test/conf/applicationContext-contract4j5.xml</code>: The application context configuration file that defines the "wiring".</li> 		  
	<li><code>test/conf/contract4j.properties</code>: A properties files used by the config. file.</li>
</ul>
<p>
An example of running the test suite using Contract4J5 with Load-Time Weaving (LTW) is also included. (The details of using LTW were discussed above.)</p>
<p>
<b>WARNING</b>: LTW requires AspectJ 1.5.2a to work, due to a bug in 1.5.2.</p>
<p>
To run the tests using load-time weaving, first <code>build all</code> as
above, then build the following target:
<pre>
	3a) ./build.sh test.loadtime.weaving (*nix)
	3b) build.bat test.loadtime.weaving  (windows)
</pre>
or
<pre>
	3c) ant test.loadtime.weaving
</pre>
This target will run the tests, using load-time weaving of the aspects on the fly.</p>
<br/><p>
Next, we'll look at code examples, then return to a discussion of invoking and
configuring Contract4J5.</p>


<a name="showme"></a>
<h4>Show Me the Code!</h4>
<p>
Here is a large example showing how to define Contract4J5 tests in your code 
so that Contract4J5 can discover and execute them at runtime. It is the file
"test/org/Contract4J5/test/BaseTestClass.java" (with some superfluous details
omitted). See additional examples in the unit/acceptance suite under the "test" directory.</p>
<p>
The comments in this class should be self explanatory. More specific details on writing contracts are provided below.
<br/>
<b>BaseTestClass.java:</b>
<pre>
package org.contract4j5.test;

import org.contract4j5.Contract;
import org.contract4j5.Invar;
import org.contract4j5.Post;
import org.contract4j5.Pre;
/**
 * A (contrived) example Java class that demonstrates how 
 * to define DbC tests. The "@Contract" annotation is 
 * required. Then, we define a class-level invariant, 
 * which happens to be for one of the fields. Note that 
 * we have to prefix the field name with "$this", one of 
 * several special keywords that begin with "$" and are
 * replaced with special values before passing the 
 * expression to the script interpreter. In this case,
 * "$this" means "this object" (You can't just use "this"
 * without the "$" for backwards compatibility reasons;
 * this may be relaxed in a future release). 
 * Prefixing field names with $this is necessary for the
 * scripting engine to be able to resolve the variable
 * name. While not required in all cases, as a rule it is
 * best to always refer to fields this way for consistent.
 * The one case where you don't need the "$this." is when
 * you define an invariant for a field itself (See the 
 * test for "name" below). Note also that in order for
 * Jexl to resolve the field reference, a JavaBeans
 * "getter" method must exist for the field, even if the
 * field is public!
 */
@Contract
@Invar("$this.lazyPi==3.14159")	// see comments for "lazyPi"
public class BaseTestClass {
  /**
   * A field that is initialized "lazily", but cannot 
   * change after that. This invariance is enforced by the 
   * @Invar annotation on the class. The constructor must 
   * call {@link #getLazyPi()} BEFORE ANY OTHER PUBLIC
   * FUNCTION, or the invariant test will fail!
   * NOTE: the Jexl parser chokes if the invariant test 
   * appends "f" to the constant!
   * NOTE: Jexl can't resolve "lazyPi" unless "getLazyPi()"
   * exists!
   */
  private float lazyPi = -1f;

  /**
   * "getLazyPi()" always simply sets the value to 3.14159,
   * so the class invariant "$this.lazyPi==3.14159" will 
   * always pass. However, see {@link #setLazyPi(float)}.
   * @return pi
   */
  public float getLazyPi() {
    if (lazyPi == -1f) {
      lazyPi = 3.14159f;
    }
    return lazyPi;
  }

  /**
   * This function allows unit tests to force a failure!
   */ 
  public void setLazyPi (float f) {
    lazyPi = f;
  }

  /**
   * A field that should never be null or "". See also 
   * comments in {@link #setName(String)}. Note that you 
   * can safely use the "bare" field name "name" here. 
   * You can also use "$this.name", which you have to use
   * in all other types of tests (i.e., tests other than 
   * the invariant test on the field itself). You can also
   * use the keyword "$target", which currently is only 
   * used to refer to a corresponding field when used in a
   * test expression. (In the future, "$target" may have 
   * other uses in the more general AspectJ-sense of the 
   * poincut "target()" expression.)
   * NOTE: You can specify an optional error message that
   * will be reported with any failure message. Also, as
   * stated before, "name" must have a "getName()" 
   * accessor or Jexl can't resolve it!
   */
  @Invar(value="name != null && name.length() > 0",
   message="this.name must never be null!")
  private String name;

  /**
   * @return String name of the object
   */
  public String getName() { return this.name; }

  /**
   * Use a precondition to prevent setting name to null. 
   * Note this test is less restrictive than the invariant
   * test on the field itself, a poor design. (Hopefully, 
   * the developer will realize the mistake when one test
   * fails while the other passes.) In this case, this 
   * "mistake" is useful for the dbc4j unit tests.
   * @param name String naming the object
   */    
  @Pre("name != null")
  public void setName (String name) { this.name = name; }

  // A flag; used for other contract tests.
  private boolean flag;

  /**
   * Set the flag.
   */
  public void setFlag () { flag = true; }

  /**
   * Set the flag. This method is used in unit tests to  
   * force a contract assertion failures.
   */
  public void setFlag (boolean f) { flag = f; }

  /**
   * Constructor. Note that the precondition on the "name"
   * parameter is redundant, since {@link #setName(String)}
   * is called, but it is still useful for documenting the 
   * interface. Note that the @Pre test does not
   * define a test expression. In this case, C4J5 uses a 
   * {@link org.contract4j5.testexpression.DefaultTestExpressionMaker}
   * to generate a default test expression. There are 
   * separate "makers" for different types of tests and 
   * contexts and they are user configurable. For 
   * preconditions, the default is to require that all
   * arguments are non-null.
   * Note that tests can call methods, too, but watch for 
   * side effects, especially since tests will normally be 
   * disabled in production builds. Therefore, never call 
   * a method with side effects!
   * @param name a non-null String
   */
  @Pre
  @Post ("$this.isValid() == true")
  public BaseTestClass (String name) {
    /* float ignore = */ getLazyPi();
    setName (name);
    setFlag ();
  }

  /**
   * Constructor. As discussed in {@link 
   * #BaseTestClass(String)}, the default test expression 
   * for the precondition test will be that all parameters,
   * in this case "name" and "flag", must be non-null. What 
   * does that mean for "flag", which is boolean. Not much; 
   * this argument will be converted to
   * {@link java.lang.Boolean} internally and it will never
   * be null! Also, in this example, the precondition test 
   * is actually redundant, since {@link #setName(String)} 
   * is called. However, the test is still useful for 
   * documenting the interface.
   * @param name a non-null String
   * @param flag a boolean flag; if false, causes the 
   *    postcondition to fail.
   */
  @Pre
  @Post ("$this.isValid() == true") // watch for side effects!
  public BaseTestClass (String name, boolean flag) {
    /* float ignore = */ getLazyPi();
    setName (name);
    setFlag (flag);
  }

  /**
   * Is the object valid?
   */
  public boolean isValid () {
    System.out.println ("ExampleClass.isValid(): flag: "+flag);
    return flag;		// reusing our flag...
  }

  /** 
   * Method that requires flag to have been previously set.
   * E.g., {@link #setFlag(boolean)}, {@link #doIt()}, etc.
   * Note the postcondition to confirm that the method 
   * succeeded, where "$return" is the keyword that matches
   * the value returned by the method (an int in this case).
   */
  @Pre(value="$this.flag == true", 
        message="this.flag true before calling 'doIt()'?")
  @Post("$return == 0")
  public int doIt () {
    if (name != null && name.equals("bad name")) {
      return 1;
    }
    return 0;
  }

  /** 
   * Overloaded method. Useful to confirm that the 
   * generated tests correctly discriminate between the 
   * methods (note the conflicting @Post annotations on the 
   * two versions.)
   */
  @Post("$return != 0")
  public int doIt (int toss) {
    if (name.equals("good name")) {
      return 1;
    }
    return 0;
  }

  /** 
   * Method with tests on more than one parameter. The 
   * keywords "$args[n]" refer to the parameter arguments, 
   * counting from 0.
   */
  @Pre ("$args[0]> 0 && $args[1].equals(\"foo\")") 
  public int doThat (int toss, String fooStr) {
    return toss;
  }

  /** 
   * Method with tests on more than one parameter. Tests 
   * whether we correctly generate matching aspects on the 
   * second and last parameter. Note that a nested string
   * in a test must be escaped.
   */
  @Pre ("toss2 > 0 && toss4.equals(\"foo\")") 
  public int doTheOther (int toss1, int toss2, 
                         String toss3, String toss4) {
    return toss1;
  }

  /**
   * Test Contract4J5 with a nested class
   */
  @Contract()
  public static class NestedBaseTestClass {
    private String name;
    @Post
    public String getName() {
      return name;
    }

    @Pre
    public void setName(String name) {
      this.name = name;
    }

    @Invar ("$target > 0")
    private int positive;

    /**
     * Method to force the invariant test to fail, 
     * if a negative argument is used.
     */
    public void setPositive (int p) { this.positive = p; }

    public int getPositive () { return this.positive; }

    // The @Post on "name" should really be a @Pre on "nm",
    // as it is more restrictive, but it is useful for 
    // example purposes.
    @Post ("$this.name != null && $this.name.length() > 0 && nm != null")  
    NestedBaseTestClass (String nm) {
      this.name = nm;
      this.positive  = nm != null ? nm.length() : -1;
    }
  }
}
</pre>

<a name='details'></a>
<h4>Details of Contract Specifications</h4>
<p>
Here are the rules for using Contract4J5, which clarify the examples just
discussed.</p>

<h5>Annotate Interfaces and Classes with "@Contract"</h5>
<p>
Examples:
<pre>
<b>@Contract</b>
public interface Foo { ... } 

<b>@Contract</b>
public class Bar { ... } 
</pre>

Any interface or class that declares a contract must be annotated with 
<code><b>@Contract</b></code>. Otherwise, the tests will be ignored. C4J5 will issue a warning 
during compilation, but if you use javac to compile and then weave later with
ajc, you may not get any warnings and the tests will be silently ignored.</p>
<p>
The annotation must also appear on any derived interfaces or classes if they
define new tests.</p>

<h5>Define Class Invariants</h5>
<p>
Examples:
<pre>
<b>@Contract</b>
<b>@Invar("boolean_test_expression")</b>
public interface Foo { ... }

<b>@Contract</b>
<b>@Invar(value="boolean_test_expression", message="The test failed")</b>
public class Bar { ... }
</pre>
The second example shows the optional "message" that will be reported on error,
in addition to standard messages. The test expression must return boolean, or
it will be treated as a contract failure!</p>
<p>
For subclasses, it isn't necessary to annotate them, too, because class-level
annotations are inherited, but you can do so for consistency with method 
annotations, which aren't inherited and must be added to subclass overrides.</p>

<h5>Define Field Invariants</h5>
<p>
Examples:
<pre>
<b>@Contract</b>
public class Bar {
  <b>@Invar("name != null && name.length() > 0")</b>
  private String name;
  public  String getName() { return name; }
  ...
}
</pre>
Note that field invariants can't be defined on interfaces, since they don't have
mutable fields, but you can simulate the same thing by annotating corresponding
accessor methods in the interfaces (see below).</p>
<p>
Note that for the field "name", we are able to use the "bare" field name when
defining an invariant test for it. You can also use "$this.name" or the
"$target" keyword.</p>
<p>
<b>WARNING!</b> As discussed previously, the JEXL
interpreter can only resolve the field
if a JavaBeans "getter" method is defined for it, as shown in the example!</p>
<p>
In the future, "$target" may be used more generally for objects that correspond
to AspectJ's "target()" pointcut expression, but currently "$target" is only 
used in field invariant tests to refer to the field.)</p>

<h5>Define Method and Constructor Preconditions, Postconditions, and Invariants</h5>
<p>
<b>NOTE:</b> we have to use "$this.name" in the following interface example, not just
"name" by itself, because we are no longer defining a field invariant test! Repeating for emphasis, don't forget that a field getter method is required 
for Jexl to resolve the field reference.</p>
<p>
Examples:
<pre>
<b>@Contract</b>
public interface Foo {
  <b>@Invar("$this.name != null && $this.name.length() > 0")</b>
  String getName();

  <b>@Invar("$this.name != null && $this.name.length() > 0")</b>
  void setName (String s);

  <b>@Pre("$args[0] > 0")</b>
  <b>@Post("$this.i = $old($this.i) + $args[0]")</b>
  void incrementI (int amount);
  ...
}

<b>@Contract</b>
public class FooImpl implements Foo {
  <b>@Invar</b>
  public String getName() {...}

  <b>@Invar</b>
  public void setName (String s) {...}

  <b>@Pre @Post</b>
  void incrementI (int amount) {...}

  int getI() { ... }     // getter method required by Jexl!
  ...
}

<b>@Contract</b>
public class Bar {
  private float factor;

  <b>@Pre("fudge > 1.0")</b>
  <b>@Post("$this.factor > 1.0")</b>
  void addFudgeFactor (float fudge) {...}

  <b>@Pre("factor > 0.0")</b>
  <b>@Post("$this.factor > 0.0")</b>
  public Bar (float factor) {
    this.factor = factor;
  }

  float getFactor() { ... }   // getter required by Jexl!
}
</pre>
The "Foo" interface simulates a field invariant test on an implied name field by
defining invariant tests on name's accessor methods. The precondition test for
"incrementI" requires the input amount to be positive. (You could also write
this test "amount > 0", but this is actually less robust; it is more likely to 
trip over parsing idiosyncrasies in Contract4J5 and Jexl.) This test implies an 
"int i" field, as does the post condition test which requires that the new
value of "i" be equal to the old value (grabbed by the "$old($this.i)" 
expression) plus the amount.</p>
<p>
The "FooImpl" implementing class MUST repeat the annotations, but it can omit
the test expressions. Contract4J5 will determine the expressions from the parent
class or interface.</p>
<p>
What if you omit the expressions? Currently, there is no compile-time checking
possible the tests will not be evaluated on these method implementations. For
subclass overrides of parent class methods, the tests will not be evaluated on
the overrides, but they will be evaluated on the parent methods if "super" is
called.</p>
<p>
<b>NOTE:</b> A desired future enhancement is to either enforce proper usage of the 
annotations on implementing classes or subclasses or else evaluate the tests 
even when they are absent!</p>
<p>
The "Bar" class shows that tests can also be defined for constructors. 
(Invariant tests are also allowed, but seldom useful, since contract tests
mostly focus on object state, which won't exist before construction!)</p>
<p>
Note the idiom for the "@Pre" and "@Post" test expressions for the "Bar"
constructor. The "@Pre" expression references the "factor" <i>parameter</i>, 
while the "@Post" expression references the factor <i>field</i>, using the
"$this." prefix. <i>A common mistake is to omit the "$this." causing the test
to be executed with the parameter value instead.</i>
<p>
<b>NOTE:</b> Jexl appears to choke if floats have a trailing "f". As shown in the 
example, they should be omitted.</p>

<h5>Special Keywords</h5>
<p>
The previous examples use the special keywords. Contract4J5 substitutes the
correct values before invoking the scripting engine to evaluate the expressions. Here is a
description of the keywords and their proper use.
<table border='1'>
	<tr><th>Keyword</th><th>Usage</th></tr>
	<tr><td><code>$this</code></td><td>The "this" object under test.</td></tr>
<tr><td><code>$target</code></td><td>A field in an invariant test. There
	<b>must</b> be a corresponding JavaBeans "getter" method or Jexl won't be able to resolve the field.</td></tr>
<tr><td><code>$result</code></td><td>The return result of a method; only valid in postconditions.</td></tr>
<tr><td><code>$args[n]</code></td><td>The "nth" argument in a parameter list.</td></tr>
<tr><td valign="top"><code>$old(..)</code></td><td>The "old" value (before a method is actually executed) of the 
  contents of the expression, which can be one of the following:
	<table border='1'>
  	<tr><td><code>$old($this)</code></td><td>Not recommended, because only the reference is saved 
                      and the object pointed to by "this" may change! Use 
                       fields or method calls instead.
    <tr><td><code>$old($target)</code></td><td>equal to $old($this.field). Be careful if "field" is
                       mutable; the value is not saved, just the reference to
                       the object!
    <tr><td><code>$old($this.field)</code></td><td>Recommended usage, if "field" is primitive, in 
                       which case the value is captured, or it refers to an 
                       immutable object. Same for $old($target.otherField) 
    <tr><td><code>$old($this.method(x,y))</code></td><td>The returned value is saved. Due to parser
                       limitations, method calls may not contain nested method
                       calls.</td></tr>
	</table>
</td></tr>
</table>
The most important thing to remember about "$old(..)" is that Contract4J5 only
remembers the value, which may be a reference to a mutable object. (We can't 
rely on "clone()" working.) Try to use it only with primitives or immutable
objects like strings.</p>

<h5>Test Expression Best Practices</h5>
<p>
This section outlines the right way to write test expressions, reflecting the
limitations of Contract4J5 and the different supported scripting engines. For detailed examples, see the code in 
the test suite.</p>

<h6>Default Test Expressions</h6>
<p>
If a contract annotation is used with no test expression, a default expression
will be inferred with possible. For cases where no test can be inferred, it
is considered an error, but this can be overridden with an API call:
<pre>
  ExpressionInterpreter.setTreatEmptyTestExpressionAsValidTest(boolean);
</pre>
If the test is on an element with no superclass equivalent, the following
default rules apply:
<table border='1'>
	<tr><td><code>@Pre</code></td><td>All arguments are expected to be non-null, which means there is no meaningful default test for primitive arguments.</td></tr>
	<tr><td><code>@Post</code></td><td>The return value is expected to be non-null, unless the method returns void.</td></tr>
	<tr><td><code>@Invar</code></td><td>There is no default expression except for field invariants, where the field is expected to be non-null.</td></tr>
</table>
<p>
For elements with superclass equivalents, the following rules apply.
First, recall that preconditions and postconditions can only be used on
methods and constructors. Also, because Java5 method annotations are never
inherited, you MUST annotate any method with the same annotations found on
its parent. However, the test expressions can be empty and if so, the 
corresponding test defined in the parent element will be used. Note that if
you don't put the annotations on derived class overrides, if they call the
parent methods, the parent methods will be tested, but not anything the
override does (including constructors).</p>
<p>
API calls exist in the org.contract4j5.aspects.*.aj aspects to specify
customized objects for calculating a default expression at runtime. These 
objects must implement
<pre>
  org.contract4j5.testexpression.DefaultTestExpressionMaker.
</pre>

<h6>Inheritance Rules for Annotation Test Expressions</h6>
<p>
This was discussed in depth above, in the section titled 
<a href='#how'>How Does Contract4J5 Support Design by Contract?</a>.</p>

<h6>$this refers to the object being tested.</h6>
<p>
You can call any public method on 
the object in the test expression; the scripting engine will resolve the type. 
Additionally, if you refer to a bare field that is not public, the scripting
engine will convert the expression to the corresponding "getter" call. 
Unfortunately, it appears that the getter method is actually <b>required</b>
in order for Jexl to resolve the field; it won't just use the bare field 
directly.</p>

<h6>$target currently is used only to refer to the field in a field invariant
test.</h6>
<p>
Future use may include any context associated with the "target()" 
pointcut expression. Just as for $this, you can reference any method or field 
defined for the object.</p>

<h6>$return is the value returned by a method.</h6>
<p>
It is only valid in 
postcondition tests. As for $this, you can reference any method or field 
defined for the object.</p>

<h6>$args[] are the arguments passed to a method, indexed starting at zero.</h6>
<p>
You can also use the declared argument name. However, if the name shadows an
instance field, the parser may confuse the two; use the appropriate $arg[n] in
this case. As for $this, you can reference any method or field defined for the
objects in the array.</p>

<h6>Use of the "$old(..)" Keyword</h6>
<p>
The "old" $old(..) keyword tells Contract4J5 to remember the value of the
contained expression before evaluating evaluating the join point, so that 
value can be compared to the "new" value after evaluating the join point.
It can only be used in @Invar and @Post condition tests and the saved value
is forgotten once the test completes.</p>
<p>
The most important thing to remember about "$old(..)" is that Contract4J5 only
remembers the value, which may be a reference to a mutable object. Since
"clone()" is not guaranteed by Java to be publicly available on an object, we
can't clone it and it was deemed too "obscure" to only permit, for example
"$old($this)" on objects where clone is publicly available. Hence, you should
try to use the $old keyword only with primitives or references to immutable
like strings.</p>
<p>
Here are the allowed expressions.
<table border='1'>
  <tr><td>$old($this)</td><td>Not recommended, since only the reference is saved.</td></tr>
  <tr><td>$old($target)</td><td>Equal to $old($this.field). Be careful if "field" is a reference to a
    mutable object!</td></tr>
  <tr><td>$old($this.field)</td><td>Recommended usage, if "field" is primitive. A synonym for
    $old($target) when used in a field invariant test.</td></tr> 
  <tr><td>$old($this.method(x,y))</td><td>Method call where the returned value is saved. Due to current parser
    limitations, nested method calls are not supported. So, the following
    is okay:
<pre>
  $old($this.getFoo().doIt(1))
</pre>
    but this is not
<pre>
  $old($this.getFoo().doIt(getIntI()))
</pre></td></tr>
</table>

<h6>References to Instance Fields</h6>
<p>
For fields, Jexl will automatically convert a "bare" field reference to its
accessor, even if the field is private. Hence, an expression like
<pre>
  $this.foo.bar.baz.doIt(1)
</pre>
is allowed and will be translated to
<pre>
  $this.getFoo().getBar().getBaz().doIt(1)
</pre>
<b>Note:</b> In fact, the corresponding getter methods are <b>required</b> or Jexl will not
be able to resolve the field references.</p>
<p>
Normally, you should prepend "$this." before a "bare" field reference as the
parser does not always correctly resolve the reference to an instance field.
The one case where "$this" is unnecessary is inside a field invariant test.
Using the field's "bare" name will work. As an alternative in field invariant 
tests, "$target" can be used to refer to the field.</p>
<p>
Note the example previously where a field invariant test was written with the 
bare field called "name", but when a set of "conceptually similar" @Pre and 
@Post tests were written in an interface on "setName()" and "getName()" methods,
it was necessary to use "$this.name". Contract4J5 may not resolve the field
correctly in those cases.  </p>
<p>
	
<h6>Tests Defined on Interfaces</h6>
<p>
You can define tests on interfaces and their methods. In fact, you are urged
to do so. Unfortunately, for reasons discussed previously, you must include
the same annotations, although not their test expressions, on the declarations
of the method implementations in implementing classes. Contract4J5 will find
the test expressions in the interfaces.</p>
<p>
Unfortunately, you can't define contract tests for constructors, since they
don't exist in an interface. You may be able to work around this using class
invariants and tests on instance methods. Note that you can also implicitly 
define field invariant tests, either on declared accessor methods or as 
invariants on the class itself. You can refer to the (implied) bare field in
the test, as long as you declare an appropriate accessor method for it.</p>

<a name="tips"></a>
<h4>Miscellaneous Notes and Debugging Tips</h4>
<ul>
	<li>All test expressions must evaluate to a boolean value.</li>
 	<li>Test expressions that fail to be evaluated by the scripting engine are treated as test failures, on the grounds that the expression is buggy in this case! 		Note that if an annotation is empty (<i>i.e.,</i> it doesn't define a test expression), then it is considered an error if a default expression can't be inferred and no corresponding test exists on a parent class. However, there is an API call to allow empty tests,
	<code>ExpressionInterpreter.setTreatEmptyTestExpressionAsValidTest(boolean)</code> in the <code>org.contract4j5.interpreter</code> package).</li>
	<li>When a test fails due to a buggy or empty test expression, as just described, a subclass of <code>ContractError</code> is thrown,
		<code>TestSpecificationError</code> (new as of v0.6.0).</li>
  <li>Remember that when using Jexl, if any test accesses an instance field, the field 
<b>must</b> have a corresponding JavaBeans getter method. Otherwise, Jexl will
fail to resolve the field and the test will fail.</li>
  <li>Fields in expressions must be prefixed with <code>$this.</code>, except in
field <code>@Invar</code> test expressions. Jexl is more forgiving if you omit the prefix.</li>
	<li>Avoid expressions with side effects. Since tests will usually be turned 
off in production, test expressions with side effects, e.g., assignments, will
not be evaluated, thereby changing the logical behavior of the application.</li>
	<li>Because runtime expression evaluation is very slow compared to compiled
code, consider embedding non-trivial tests in "validation" methods and calling
them from the test expression. (Prepend instance tests with "$this.")</li>
	<li>White space follows the same rules for Java. For the "$" keywords, white
space is not allowed between the '$' and the word.</li>
	<li>Jexl can't parse literal floats and doubles with the 'f' and 'd' appended, respectively. Leave them off in both cases.</li>
	<li>Most other Java expressions, like comparisons and arithmetic expressions can be used. See the <a href="http://jakarta.apache.org/commons/jexl/">Jexl website</a> for more information on allowed expressions.</li>
	<li>Before passing the expressions to Jexl, substitutions are made. Normally, you shouldn't case, but when debugging, you may see strings with these substitutions. All the '$' keywords are changed. For example, 
		<table>
			<tr><td>$this</td><td><i>becomes</i>&nbsp;</td><td>c4jThis</td></tr>
			<tr><td>$target</td><td><i>becomes</i>&nbsp;</td><td>c4jTarget</td></tr>
			<tr><td>$old($this)</td><td><i>becomes</i>&nbsp;</td><td>c4jOldThis</td></tr>
			<tr><td>$old($target)</td><td><i>becomes</i>&nbsp;</td><td>c4jOldTarget</td></tr>
			<tr><td align="left" colspan="3"><i>etc.</i></td></tr>
		</table></li>
	<li>Turn on DEBUG logging to see what expressions are being evaluated and
some of the substitutions that are made.</li>
	<li>Some common expression errors have "canned" strings defined for them in
  <code>org.contract4j5.interpreter.ExpressionInterpreter.java</code>.
Most of the heavy lifting of expression evaluation BEFORE sending it to 
the scripting engine is done in 
<code>org.contract4j5.interpreter.ExpressionInterpreterHelper.java</code>
The wrapper for Jexl, Groovy, and JRuby themselves are
<code>org.contract4j5.interpreter.jexl.JexlExpressionInterpreter.java</code>,
<code>org.contract4j5.interpreter.groovy.GroovyExpressionInterpreter.java</code>, and
<code>org.contract4j5.interpreter.jruby.JRubyExpressionInterpreter.java</code>,
respectively.</li>
	<li>If you are using the properties configurator and you want to specify a language other
than Jexl (or the default Groovy), you have to create your own subclass of 
<code>BSFExpressionInterpreterAdapter</code> that specifies the language to use. 
See the example <code>JexlBSFExpressionInterpreter</code> that does this for Jexl.
This is because the properties configurator does not currently support specifying
<code>BSFExpressionInterpreterAdapter</code> as the interpreter class with a 
language property field.</li>
</ul>

<a name="config"></a>
<h4>Configuration of Contract4J5</h4>
<p>
To configure the behavior, the v0.6.0 release greatly expanded the options for 
configuring Contract4J5. In addition to the previous support for configuration 
through API calls, you can now customize most behavior using property files 
or by using Spring Dependency Injection. Besides setting properties such as 
which types of tests to enable, whether or not to print the stack trace when 
contracts fail, <i>etc.</i>, you can also specify your own classes to satisfy 
particular dependencies (<i>e.g.</i>, the expression interpreter).</p>
<p>
We recommend using a standard mechanism like Spring's Dependency 
Injection (DI) for nontrivial configuration. (See the Spring example that is
part of this release.) However, for simple property configuration, property 
files are fine; see the unit test <code>PropertiesConfiguratorTest.java</code>
in the <code>org.contract4j5.configurator.test</code> package for examples.</p>
<p>
Note that Contract4J5 will use reasonable defaults if you don't do any 
configuration.</p>
<p>
Here are some API examples. Note that the internal restructuring done in the 
v0.6.0 release changed the wiring API significantly compared to previous 
releases. 
<pre>
  import org.contract4j5.aspects.Contract4J5;
  ...
  Contract4J5.getInstance().setEnabled(Contract4J5.TestType.Pre,   true);
  Contract4J5.getInstance().setEnabled(Contract4J5.TestType.Post,  true);
  Contract4J5.getInstance().setEnabled(Contract4J5.TestType.Invar, true);
</pre>
<p>
This example turns on all three test types. Note that in v0.5 and earlier releases, the <code>getInstance()</code> call would not have been used. The
<code>Contract5J</code> object was an aspect and it is now a class with a singleton instance.</p>
<p>
<b>NOTE:</b> To completely disable contract checking, build the application 
without "contract4j5.jar" in your path. This is recommended for "production" 
builds when you don't want any test overhead.</p>
<p>
There are several key components in Contract4J5 that are configurable:</p>
<table border="1">
	<tr><td>ExpressionInterpreter</td><td>Wraps Jexl, Groovy, or JRuby (could also wrap otheralternatives)</td></tr>
  <tr><td>ContractEnforcer</td><td>Handles test invocation and failure handling</td></tr>
  <tr><td>Reporter</td><td>Simple output/logging wrapper.</td></tr>
</table>
<p>
Note that a runtime warning are issued if the ExpressionInterpreter or 
ContractEnforcer are not defined, as tests can't be run otherwise. The 
Reporter objects will default to stdout/stderr if undefined.</p>
<p>
Here are more details about these component interfaces and implementing
classes:
<table border="1">
  <tr><td><code>org.contract4j5.enforcer.ContractEnforcer:</code><br/>
  The "enforcer" interface</td></tr>
  <tr><td><code>org.contract4j5.enforcer.ContractEnforcerImpl:</code><br/>
  The one implementation used here. It runs the tests and on failure, logs
  a detailed error message and terminates program execution.</td></tr>
  <tr><td><code>org.contract4j5.interpreter.ExpressionInterpreter:</code><br/>
 The expression interpreter interface.</td></tr>
 <tr><td><code>org.contract4j5.interpreter.ExpressionInterpreterHelper:</code><br/>
  An abstract helper class that provides a partial implementation. Subclass this class to support the actual interpreters.</td></tr>
  <tr><td><code>org.contract4j5.interpreter.jexl.JexlExpressionInterpreter:</code><br/>
The Jexl implementation of the interpreter.</td></tr>
  <tr><td><code>org.contract4j5.interpreter.groovy.GroovyExpressionInterpreter:</code><br/>
The Groovy implementation of the interpreter.</td></tr>
  <tr><td><code>org.contract4j5.interpreter.jruby.JRubyExpressionInterpreter:</code><br/>
The JRuby implementation of the interpreter.</td></tr>
  <tr><td><code>org.contract4j5.util.reporter.Reporter:</code><br/>
  The "reporter" interface that is a thin veneer for a logging abstraction.</td></tr>
  <tr><td><code>org.contract4j5.util.reporter.Severity:</code><br/>
    Defines logging levels of severity, like INFO, WARN, ERROR, etc.</td></tr>
  <tr><td><code>org.contract4j5.util.reporter.WriterReporter:</code><br/>
    "Logs" to stdout and stderr by default, but also supports file output. 
    It would be very easy to implement a "log4j reporter", for example.</td></tr>
</table>
<p><b>Notes:</b></p>
<ol>
	<li>For most properties currently defined, if a value is empty, it is ignored! In some cases, warnings are issued.</li>
 	<li>In pre-v0.6.0 releases, the fields in the aspects were static, <i>e.g.</i>,
  <code>ConstructorBoundaryConditions.getDefaultPreTestExpressionMaker()</code>.
Now, you get the "aspectOf()" instance first:
  <code>ConstructorBoundaryConditions.aspectOf().getDefaultPreTestExpressionMaker()</code>.</li>

	<li>The type <code>Contract4J5</code> was an aspect in pre-v0.6.0 releases. It is now a class and a singleton instance is used. Hence,
   <code>Contract4J5.setEnabled(Contract4J5.TestType.Pre, true);</code>
is now
  <code>Contract4J5.getInstance().setEnabled(Contract4J5.TestType.Pre, true);</code>.</li>
</ol>


<h5>Building Contract4J5</h5>
<p>
To build Contract4J5 the following third-party tools are required, along with 
corresponding "HOME" environment variable definitions needed by the ant build 
scripts:
<ol>
	<li>JUnit 3.8.1 (<code>JUNIT_HOME</code>)</li>
	<li>Java 5 (<code>JAVA_HOME</code>)</li>
	<li>AspectJ 1.5 (<code>ASPECTJ_HOME</code>) The 1.5.2a or later release is recommended (required if you do load-time weaving).</li>
	<li>Ant 1.6.2+ (<code>ANT_HOME</code>)</li>
	<li>Jexl 1.0 (<code>Jexl_HOME</code>)</li>
	<li>Commons Logging (<code>COMMONS_LOGGING_HOME</code>)</li>
</ol>
Also define <code>Contract4J5_HOME</code> to be the <code>.../contract4j5_060/contract4j5</code>
directory where you installed it.</p>
<p>
For your convenience, you can use the build driver script "build.sh" or "build.bat". Edit the values of the environment variables in the corresponding scripts "env.sh" or "env.bat" for your environment.</p>
<p>
Only Java, AspectJ, and Jexl are required if you simply use the binary 
</code>contract4j5.jar</code> in the distribution. Make sure your build process either 
compiles with AspectJ or weaves your precompiled jars or class files with 
</code>contract4j5.jar</code>.</p>

<a name="todo"></a>
<h4>TODO Items</h4>
<p>
Here is a brief list of some of the more important "TODO" items, roughly in 
order of importance. 
<ol>
	<li>Automatically enforce proper usage of method and constructor annotations in
subclasses when they aren't annotated.</li>
	<li>Implement correct contravariant behavior of inherited precondition tests and covariant behavior of inherited postcondition tests.</li>
	<li>Support other scripting languages, especially Groovy and JRuby in Java 5.</li>
	<li>Support other scripting languages, especially Groovy and JRuby, using the native scripting support in Java 6.</li>
	<li>Support end-user extension with custom annotations and failure handlers.</li>
	<li>Support tests on static methods.</li>
	<li>Extend <code>@Pre</code> and <code>@Post</code> to support class-level annotations that will apply to all protected and public instance and static methods. For example, <code>@Contract @Pre @Post public class Foo {...}</code> would require all such methods to take non-null arguments and return non-null values, consistent with the way <code>@Pre</code> and <code>@Post</code> work by default today on methods. Add optional configuration properties to each annotation to set the protection level for which the annotation applies (<i>e.g.</i>, also do private methods.) and whether or not to exclude static methods.</li>
	<li>Find a more elegant, aspectj-specific way to handle logging of information
	without embedding the ad hoc Reporter objects.</li>
	<li>Refine test handling. For example, field invariants are evaluated for reads,
but this probably only makes sense for the very first read, in case it is 
uninitialized. The rest of the time, evaluating just field writes makes sense.</li>
	<li>Eliminate the requirement to annotate the class with @Contract?
	<li>For the keywords:
		<ul>
			<li>Allow "this" without the '$'? </li>
			<li>Provide a "$field" alias for "$target", since the latter isn't used for anything other than fields. Keep "$target" for backwards compatibility.</li>
		</ul></li>
	<li>Find a more elegant, aspectj-specific way to handle logging of information
without embedding the ad hoc Reporter objects.</li>
</ol>

<a name="notes"></a>
<h4>Notes for Each Release</h4>

<h5>v0.7.0 December 31, 2006</h5>
<h6>Support Groovy, JRuby, and Other Refinements</h6>
<p>
This release adds built-in support for using Groovy or JRuby as an alternative
to Jexl as the scripting engine. In fact, because of Jexl limitations, it is
now deprecated; Groovy is the default scripting language at startup. (This is
easily configurable, as discussed previously.) In our experiments, most
Jexl-compatible expressions work just fine with Groovy. Using JRuby will
require porting existing expressions.
</p>

<p>
All scripting engine calls now go through the Jakarta
<a href=""http://jakarta.apache.org/bsf/">Bean Scripting Framework</a> (BSF),
including Jexl, to make it easier to plug and play almost any scripting engine.
These changes introduce the following new library dependencies:
</p>
<table border="1">
<tr><th>Scripting Engine</th><th>Required Libraries</th></tr>
<tr><td><i>All</i></td><td><code>bsf-2.4.X.jar</code>, <code>commons-logging.jar-1.0.X.jar</code></td></tr>
<tr><td>Jexl</td><td><i>All</i> plus <code>commons-jexl-1.0.X.jar</code></td></tr>
<tr><td>Groovy</td><td><i>All</i> plus <code>groovy-1.0.jar</code> (RC 1 or newer), <code>asm-2.2.jar</code>, and <code>antlr-2.7.5.jar</code></td></tr>
<tr><td>JRuby</td><td><i>All</i> plus <code>jruby-0.9.jar</code> or later</td></tr>
</table>

<p>All these jars are included with the distribution. Remove the ones you 
don't need from your deployment.</p>

<p>More robust handling of quoted strings; no more variable substitution internally!</p>

<p>We have kept the scripting language mostly compatible between Jexl and Groovy,
since they are "Java-like". JRuby has a different syntax, of course.  The following
is the partial list of differences between scripts written with Jexl and Groovy.
Some of these differences may reflect idiosyncrasies of how they are used in
the implementation, rather than real language differences. Also, in general, 
Groovy is a more full-featured language, so it provides facilities that
Jexl doesn't, such as closures.</p>

<ol>
	<li>Groovy scripts can reference fields in a class without requiring the class
	to provide an accessor method. Jexl requires the accessor.</li>
	<li>Jexl may swallow <code>ArrayIndexOutOfBoundsExceptions</code> (?) while Groovy does not.</li>
  <li>When writing tests while using Groovy, fields must be prefixed with 
	<code>$this.</code>, except in field <code>&amp;Invar</code> expressions.
	(Jexl parsing is more forgiving.) If you get a test-failure message that
	reports a <code>groovy.lang.MissingPropertyException</code> as the cause,
	make sure the test expression doesn't have a bare field reference!</li>

  <li>Jexl does seem to be able to locate package protected and protected fields
	where Groovy can.</li>
  <li>The Groovy interpreter provides more descriptive error messages when a test fails
	because the expression is bad, <i>e.g.,</i> because it references a non-existent field
	on an object. As a result, while such tests fail whether using Jexl or Groovy, debugging
	the issue will often be easier with Groovy.</li>
</ol>

<p>It is now easier to configure the behavior for what happens when a contract
failure occurs. The interface <code>ContractEnforcer</code> exposes more
configuration options, which are exercised by the unit tests, example property
files, and the Spring example. The default enforcer is now called 
<code>DefaultContractEnforcer</code> (was <code>ContractEnforcerImpl</code>),
which implements a new abstract class
<code>ContractEnforcerHelper</code>. <code>DefaultContractEnforcer</code>
implements an abstract method <code>finishFailureHandling()</code> that throws
the usual <code>ContractError</code>. Create a new subclass of the helper
that does your desired handling. One option is to override the 
<code>makeContractError()</code> method and have it return your own subclass
of <code>ContractError</code>, then catch that error in your code.</p>

<p>This change is in anticipation of a planned generalization of Contract4J to
support user-defined annotations and associated behaviors, so that the 
infrastructure can be used for a variety of applications beyond Design by
Contract.</p>

<p>This release of Contract4J was tested using the final release of Java SE
1.6.0. While it doesn't use any Java 6 features (such as the JSR-223 support
for scripting), it does offer performance improvements. The JUnit suite runs
approximately 18% faster than under Java 5 and when the load-time weaving (LTW)
test target is run, the improvement is a nice 36%!</p>

<p>Support for JSR-223 (Java 6) is under consideration.</p>

<p>The distribution now includes convenience scripts for evaluating the 
structure of Contract4J5 using
<a href="http://clarkware.com/software/JDepend.html">jdepend</a> and
<a href="http://findbugs.sourceforge.net/">findbugs</a>. 
These tools were used to restructure Contract4J5 to eliminate a number of 
circular dependencies and other problems.
See the <code>jdepend.sh</code> and <code>findbugs.txt</code> files in the
<code>contract4j5</code> directory for more information. 
</p>

<p>More clean-ups of package dependencies and generics-related warnings were
also done.</p>

<h5>v0.6.0 September 21, 2006</h5>
<h6>Restructuring</h6>
<p>
This release is a major restructuring to reduce the component complexity, to
reduce over-reliance on singletons, and to improve the "wiring" options. 
Defining contracts is unchanged (except for some bug fixes), so most users
won't be affected. However, the configuration API has changed (this is still 
pre-1.0 software!), as discussed below in these notes and elsewhere in this
README.</p>
<p>
<h6>Spring Dependency Injection Example</h6>
<p>
An example has been added that uses the <a 
href="http://www.springframework.org/">Spring Framework</a> (v1.2.5) to 
configure Contract4J5. See the separate folder called
<code>Contract4J5WithSpring</code>. Spring v2.0 configuration should be 
backwards compatable, if not easier with the new 2.0 features. However, using 
Contract4J5 with Spring v2.0 has not been tested.</p>
<h6>Improved Configuration Options</h6>
<p>The restructuring greatly improved the options for using properties files 
to "wire" Contract4J5, as an alternative to using Spring. See the tests in 
<code>org.contract4j5.configurator.test</code> for examples.</p>
<h6>New Error Thrown to Indicate Bad Test Specifications</h6> 
<p>If a test fails because the expression is empty or can't be evaluated by 
Jexl, a new subclass of <code>ContractError</code>, 
<code>TestSpecificationError</code>, is now thrown. This makes 
it easier to determine when a test failed because the test itself was bad, as
opposed to the class under test failing to meet the contract. Using a subclass
of <code>ContractError</code> means that any existing 
<code>catch (ContractError ce)</code> code will
continue to catch both kinds of failures. However, users who want to 
distinguish between the two types of errors should use this idiom:</p>
<pre>
  try {
    ...
  } catch (TestSpecificationError tse) {
    ...
  } catch (ContractError ce) {
    ...
  }
</pre>  
<h6>Binary Weaving and Load-Time Weaving Options</h6>
<p>
The build process now uses binary (jar) weaving when the "tests" are built,
providing an example of using Contract4J5 with this approach. An example of 
using load-time weaving (LTW) is also provided, using a separate test target, as discussed above.</p>
<p>
"Binary" weaving is weaving done after compiling all code, using a 
post-compilation weaving step to incorporate the Contract4J5 aspects. 
It is useful for organizations that prefer to 
use javac for all java files.</p>
<p>
Load-time weaving is done as the application loads class files, using a 
special "java agent" for this purpose. Using load-time weaving is the least
disruptive way to adopt Contract4J5 into "pure Java" environments. 
<b><i>For this reason, we recommend starting with load-time weaving</i></b>,
since this approach requires minimal changes to the existing build environment.
However, since LTW is slower than binary weaving, especially when running
numerous tests, larger projects may prefer to switch to binary weaving at
some point.</p>
<p>
Previous releases of Contract4J5 used just compile-time weaving, where ajc was 
used to compile all sources and weave the class files. This approach is still 
used to build Contract4J5's own source code (as opposed to its unit tests) and
to create the contract4j5.jar file.</p>
<h6>Miscellaneous</h6>
<ul>
	<li>Replaced the entity definitions in the build-related XML files with the ant <import> task. Apparently, NetBeans doesn't like the entity definitions. (Thanks to Matthew Harrison for bringing this to my attention and for providing refactored build files.)</li>
	<li>Added more tests that explicitly demonstrate that contract expressions that access instance properties only work if the properties have JavaBeans getter methods. This is an unfortunate Jexl limitation.</li>
	<li>Fixed numerous small bugs, including a few warnings related to generics. (Thanks to Falk Bruegmann for a generics warning fix.)</li>
</ul>

<h6>Some of the API Changes</h6>
<h7>Handling of "Reporters"</h7>
<p>
Removed the API calls to set separate <code>Reporter</code> objects (for logging) in
each major component. This greatly reduced some boilerplate code with a small 
reduction in flexibility that had dubious value. Now, a global Reporter object is
used, the one set in the singleton instance of the <code>Contract4J5</code> class.</p>
<p>
All properties on aspects are no longer static methods. Instead, use the 
<code>aspectOf()</code> method to get the instance. So for example,</p>
<pre>
  ConstructorBoundaryConditions.getDefaultPreTestExpressionMaker();
</pre>
is now
<pre>
  ConstructorBoundaryConditions.aspectOf().getDefaultPreTestExpressionMaker();
</pre>
<p>
<code>Contract4J5</code> is no longer an aspect, but a class. The aspect code was moved
to a separate aspect called <code>AbstractConditions</code>, leaving only pure-Java code.
The conversion to Java made it easier to instantiate these objects as needed, 
especially for testing, and
also to exploit the more complete support for Java in Eclipse (<i>e.g.</i>, for 
refactorings). Note that this change means that any properties that were
previously set on <code>Contract4J5</code> are <b>not</b> now accessed using 
<code>aspectOf</code>, as just described for the aspects. Instead, <code>Contract4J5</code> properties are accessed, <i>e.g.,</i> as follows:</p>
<pre>
  Contract4J5.getInstance().setEnabled(Contract4J5.TestType.Pre, true);
</pre>
<h6>Bugs</h6>
<ol>
	<li>It seems that the ant build expects Spring to be present in order to define some properties or classpaths. This causes the build to fail if Spring is not present! This is a bug in the ant scripts. <b>Workaround</b>: Install Spring
somewhere and point the "env.sh" or "env.bat" script to it. It won't actually be used unless you explicitly invoke one of the demonstration <code>*.spring</code> ant targets.</li>
</ol>

<h5>v0.5.0 February 7, 2006</h5>
<p>
Eliminated the precompilation step, replacing it with runtime teste expression
evaluation using the Jakarta Commons Jexl expression parser.</p>
<p>
The package structure has been changed from <code>com.aspectprogramming.*</code> to <code>org.contract4j5.*</code>.</p>
<p>
Deprecated several features; they aren't supported in this milestone release.</p>
<h6>Ad Hoc Configuration API</h6>
The ad hoc configuration API and full support for configuration through 
property files. Subsequent releases will "re-add" limited support for property 
file configuration, for convenience, but the preferred way to configure
Contract4J5 is through a standard dependency injection (DI) solution like 
the Spring Framework. This release does all you to globally enable or disable 
all tests or just all precondition, postcondition, or invariant tests. To use,
define one or more of the following System properties (true or false):
<table>
	<tr><td><code>org.contract4j5.Contract</code></td><td>Enable/disable all tests</td></tr>
	<tr><td><code>org.contract4j5.Pre</code></td><td>Enable/disable all precondition tests</td></tr>
	<tr><td><code>org.contract4j5.Post</code></td><td>Enable/disable all postcondition tests</td></tr>
	<tr><td><code>org.contract4j5.Invar</code></td><td>Enable/disable all invariant tests</td></tr>
</table>

<h6>The "alwaysActive" property of the V0.1 annotations</h6>
This annotation property, when used, kept a test 
"active" even if all other annotations of the same kind were disabled globally. The complexity of implementing this feature in the new architecture outweighed the benefits. Use an alternative implementation like embedded assert statements.

<h6>The "messagePrefix" and "messageSuffix" annotation properties</h6>
Similarly, these properties of the 
@Contract annotation are no longer supported. However, you can still define
individual messages in the test annotations themselves.

<h6>Annotations on method parameters</h6>
AspectJ5 has the limitation that it doesn't support annotations on method parameters. They were supported in Contract4J5 v0.1, because it didn't rely on AspectJ's support. The workaround is to put all parameter tests in a method 
precondition test.

<h5>v0.1.1.0 October 4, 2005</h5>

Support for Ant builds and numerous small bug fixes in the V1 branch.

<h5>v0.1.0.2 April 24, 2005</h5>

Fixed a bug that prevented use of precondition annotations on individual method 
parameters if the method contains more than one parameter. (The generated 
aspectj code pointcut uses the "args()" specifier. For it to match correctly, 
args() must contain the correct parameter list for the method, with the 
parameter name used for the parameter of interest and the parameter types used 
for the other parameters.)</p>
<p>
Numerous minor enhancements.</p>

<h5>v1.0.1 February 6, 2005</h5>

Minor bug fixes.

<a name="furtherinfo"></a>
<h4>For Further Information...</h4>
<p>
<a href="http://www.contract4j.org/">http://www.contract4j.org/</a> is the home page for Contract4J5 and Contract4JBeans.
It is developed by <a href="http://www.aspectresearchassociates.com/">Aspect Research Associates</a> (ARA), a consulting company specializing
in Aspect-Oriented Programming, enterprise Java, and Ruby on Rails. ARA also
manages the <a href="http://www.aspectprogramming.com/">Aspect Programming</a> web site, where you will find more information and whitepapers on Contract4J5 and 
Aspect-Oriented Software Development (AOSD), in general.</p>
<p>
The <a href="http://www.ibm.com/developerworks/views/java/libraryview.jsp?search_by=aop@work:">AOP@Work series</a> at <a href="http://www.developerWorks.com">developerWorks.com</a> contains an article about <a href="http://www-128.ibm.com/developerworks/java/library/j-aopwork17.html">Contract4J5</a>. It introduces <i>Design by Contract</i> and how Contract4J5 supports it in Java. The article concludes with a discussion
of emerging trends in Aspect-Oriented Design.</p>
<p>
The AOSD.06 Conference in Bonn, Germany (March 19-24) featured
a talk in the Industry Track on Contract4J5, specifically on the lessoned learned about
writing generic, reusable aspects in AspectJ while implementing Contract4J5. 
There was also a paper on aspect-oriented design patterns in
Contract4J5 in the ACP4IS workshop. Both papers can be found <a href='http://www.aspectprogramming.com/papers'>here</a>.</p>
<p>
The definitive site on AOSD is <a href="http://www.aosd.net">http://www.aosd.net</a>.</p>
<p>
See <a href="http://www.aspectj.org">http://www.aspectj.org</a> for information on AspectJ. Note that there are 
plans to incorporate Contract4J5 into the new standard library for AspectJ5 that is under development.</p>
<p>
For alternative approaches to doing Design by Contract in Java, see the
<a href="http://barter.sourceforge.net/">Barter</a> project, which uses XDoclet and also generates AspectJ. Barter 
partially inspired Contract4J5. </p>
<p>
JBoss AOP has basic support for contracts. Spring AOP may have similar support.</p>
<p>
There is a discussion group doing DbC in Java and possibly getting a future
version of Java to support DbC natively. See <a href="http://dbc.dev.java.net/">http://dbc.dev.java.net/</a>. However,
this effort appears to be dead for the time being.</p>
<p>
Some more sophisticated approaches to program correctness include the <a href="http://www-i2.informatik.rwth-aachen.de/Research/RV/JLO/">J-LO</a>
tool for runtime checks of temporal assertions about the program.</p>
<p>
Another project is the <a href="http://www.cs.iastate.edu/~leavens/JML/">Java Modeling Language</a> (JML), which supports DbC for Java.</p>
		</font>
	  </td>
	</tr>
	<tr>
	  <td align="center" colspan="2"> <a href="#top">top</a></td>
	</tr>
	<tr>
	  <td align="right" valign="top"> &nbsp; </td>
	  <td align="left"> <font class="Footer">Copyright &copy;
		2003-2005 Aspect Research Associates. All Rights Reserved.</font> </td>
	</tr>
  </tbody>
</table>
					<div id="copyright">
						Copyright 2003-2006 
						Aspect Research Associates. 
							All Rights Reserved.
					</div>
      </div>

	  </div>
		<br/>
		<div id="misc-rails-logos">
			<center><a href="http://www.rubyonrails.org"><img alt="Ruby on Rails" src="/images/rails2.png?1148921442" /></a>
			</center>
		</div>
  </div>

</body>
</html>
